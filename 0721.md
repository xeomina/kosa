# 0721

* 시작 전 체크

```
# docker login
# kubectl create secret generic xeomina --from-file=.dockerconfigjson=/root/.docker/config.json --type=kubernetes.io/dockerconfigjson
# kubectl patch -n default serviceaccount/default -p '{"imagePullSecrets":[{"name": "xeomina"}]}'
# kubectl describe serviceaccount default -n default
```



# Kubernetes

## 파드 노드네임 (수동 배치)

* `pod-nodename.yaml` 파일 생성

```
# vi pod-nodename.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-nodename-metadata-worker1
  labels:
    app: pod-nodename-labels
spec:
  containers:
  - name: pod-nodename-containers
    image: nginx
    ports:
    - containerPort: 80
  nodeName: worker1
---
apiVersion: v1
kind: Service
metadata:
  name: pod-nodename-service
spec:
  type: NodePort
  selector:
    app: pod-nodename-labels
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

* apply
  * worker1에 생성됨

```
# kubectl apply -f pod-nodename.yaml
# kubectl get po -o wide
```

![image-20220721092706590](md-images/0721/image-20220721092706590.png)



## 노드 셀렉터 (수동 배치)

* 라벨링
  * `worker2`에 `app=dev`

```
# kubectl label no worker2 app=dev
# kubectl get no --show-labels
```

![image-20220721093045830](md-images/0721/image-20220721093045830.png)

* `pod-nodeselector.yaml` 파일 생성

```
# vi pod-nodeselector.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-nodeselector-metadata-app
  labels:
    app: pod-nodeselector-labels
spec:
  containers:
  - name: pod-nodeselector-containers
    image: nginx
    ports:
    - containerPort: 80
  nodeSelector:
    app: dev
---
apiVersion: v1
kind: Service
metadata:
  name: pod-nodeselector-service
spec:
  type: NodePort
  selector:
    app: pod-nodeselector-labels
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

* apply

```
# kubectl apply -f pod-nodeselector.yaml
# kubectl get po -o wide
```

![image-20220721093618738](md-images/0721/image-20220721093618738.png)



* 라벨 삭제
  * `[노드 이름] <key> -`

```
# kubectl label no worker2 app-
# kubectl get no --show-labels
```

![image-20220721093757363](md-images/0721/image-20220721093757363.png)



## taint와 toleration

* master1 node 확인
  * `NoSchedule` : 자동배치에서 스케쥴러가 pod 생성을 node에 배치하지 않음

```
# kubectl describe no master1
```

![image-20220721094129143](md-images/0721/image-20220721094129143.png)



### taint

* taint

```
# kubectl taint no worker1 key1=value1:NoSchedule
# kubectl taint no worker2 key1=value1:NoSchedule
```

* taint 확인

```
# kubectl describe no worker1 | grep Taints:
# kubectl describe no worker2 | grep Taints:
```

![image-20220721095753959](md-images/0721/image-20220721095753959.png)

![image-20220721102538064](md-images/0721/image-20220721102538064.png)

* pod 생성
  *  pending 상태

```
# kubectl run test-taint --image=nginx
# kubectl get po -o wide
```

![image-20220721095853264](md-images/0721/image-20220721095853264.png)



### toleration

* `pod-taint.yaml` 파일 생성

```
# vi pod-taint.yaml
apiVersion: v1
kind: Pod
metadata:
  name: pod-taint-metadata
  labels:
    app: pod-taint-labels
spec:
  containers:
  - name: pod-taint-containers
    image: nginx
    ports:
    - containerPort: 80
  tolerations:		# taint 처리 된 node에도 pod 배치 가능
  - key: "key1"
    operator: "Equal"
    value: "value1"
    effect: "NoSchedule"
---
apiVersion: v1
kind: Service
metadata:
  name: pod-taint-service
spec:
  type: NodePort
  selector:
    app: pod-taint-labels
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

* apply

```
# kubectl apply -f pod-taint.yaml
# kubectl get po -o wide
```

![image-20220721102809870](md-images/0721/image-20220721102809870.png)





# Amazon EKS

## 개념

https://docs.aws.amazon.com/ko_kr/eks/latest/userguide/what-is-eks.html

* Amazon Elastic Kubernetes Service (Amazon EKS)는 클라우드 또는 온프레미스에서 Kubernetes 애플리케이션을 실행하고 크기를 조정하는 관리형 컨테이너 서비스입니다.

* Amazon Elastic Kubernetes Service(Amazon EKS)는 Kubernetes를 실행하는 데 사용할 수 있는 관리형 서비스입니다. AWS Kubernetes 제어 플레인 또는 노드를 설치, 작동 및 유지 관리할 필요가 없습니다. Kubernetes는 컨테이너화된 애플리케이션의 배포, 조정 및 관리 자동화를 위한 오픈 소스 시스템입니다

* 여러 AWS 가용 영역에 걸쳐 Kubernetes 제어 플레인을 실행하고 크기 조정하여 높은 가용성을 보장합니다.

* 는 하중에 따라 제어 영역 인스턴스의 크기를 자동으로 조정하고, 비정상 제어 영역 인스턴스를 감지하고 교체하며, 자동화된 버전 업데이트 및 패치를 제공합니다.

* 또한 여러 AWS 서비스와 통합되어 다음 기능을 포함한 애플리케이션에 대한 확장성과 보안을 제공합니다.

  - 컨테이너 이미지에 대한 Amazon ECR
  - 로드 분산을 위한 Elastic Load Balancing
  - 인증용 IAM
  - 격리를 위한 Amazon VPC

* 오픈 소스 Kubernetes 소프트웨어의 최신 버전을 실행하므로 Kubernetes 커뮤니티에서 모든 기존 플러그 인과 도구를 사용할 수 있습니다. Amazon EKS에서 실행되는 애플리케이션은 온프레미스 데이터 센터에서 실행 중이든 퍼블릭 클라우드에서 실행 중이든 상관없이 모든 표준 Kubernetes 환경에서 실행되는 애플리케이션과 완벽하게 호환됩니다. 즉, 필요한 코드를 수정하지 않고 표준 Kubernetes 애플리케이션을 Amazon EKS로 쉽게 마이그레이션할 수 있습니다.

* 클라우드에서 Amazon EKS를 사용하여 애플리케이션 배포

  ![Amazon EKS 작동 방식](md-images/0721/product-page-diagram_Amazon-EKS.png)

* Amazon EKS Anywhere를 사용하여 애플리케이션 배포

  ![Amazon EKS 작동 방식](md-images/0721/v3-product-page-diagram_Amazon-EKS-Anywhere.png)

* 자체 도구를 사용하여 애플리케이션 배포

  ![product-page-diagram_Amazon-EKS-Distro@2x](md-images/0721/product-page-diagram_Amazon-EKS-Distro.png)

### Amazon EKS 제어 영역 아키텍처

* Amazon EKS 는 각 클러스터에 대해 단일 테넌트 Kubernetes 제어 영역을 실행합니다. 컨트롤 플레인 인프라는 클러스터 또는 AWS 계정 간에 공유되지 않습니다. 제어 플레인은 2개 이상의 API 서버 인스턴스와 AWS 리전 내 3개의 가용 영역에서 실행되는 3개의 `etcd` 인스턴스로 구성됩니다
* Amazon EKS는 Amazon VPC 네트워크 정책을 사용하여 제어 영역 구성 요소 간의 트래픽을 단일 클러스터 내로 제한합니다. 클러스터에 대한 제어 영역 구성 요소는 Kubernetes RBAC 정책에 따라 권한을 부여받지 않은 경우 다른 클러스터 또는 다른 AWS 계정의 통신을 보거나 수신할 수 없습니다. 이 안전하고 가용성이 높은 구성을 통해 Amazon EKS는 프로덕션 워크로드에 안정적이고 권장됩니다.

![EKS-demo-app](md-images/0721/EKS-demo-app.png)

출처 : https://aws.amazon.com/ko/getting-started/hands-on/deploy-kubernetes-app-amazon-eks/



### Amazon EKS는 어떻게 작동합니까?

![     Amazon EKS 작동 방식    ](md-images/0721/what-is-eks.png)

* Amazon EKS 손쉽게 시작하기:

1. AWS Management Console 또는 AWS CLI를 사용하거나 AWS SDK를 사용하여 Amazon EKS를 생성합니다.
2. 관리형 또는 자체 관리형 Amazon EC2 노드를 실행하거나 워크로드를 AWS Fargate에 배포합니다.
3. 클러스터가 준비되면 원하는 Kubernetes 도구(예: `kubectl`)를 구성하여 클러스터와 통신할 수 있습니다.
4. 다른 Kubernetes 환경에서와 마찬가지로 Amazon EKS 클러스터에 워크로드를 배포 및 관리합니다. AWS Management Console을 사용하여 노드 및 워크로드에 대한 정보를 볼 수도 있습니다.



## 실습

* 도커 EC2 생성 - 사용자 데이터
  * api 도구 & docker host & master node에 접근하는 client
* AWS CLI 명령어 사용 : `awscliv2.zip` 파일
  * completion : 자동화

![image-20220721105316835](md-images/0721/image-20220721105316835.png)

![image-20220721105336969](md-images/0721/image-20220721105336969.png)

![image-20220721105402242](md-images/0721/image-20220721105402242.png)

```
#!/bin/bash
cd /tmp
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
./aws/install
amazon-linux-extras install docker -y
systemctl enable --now docker
curl https://raw.githubusercontent.com/docker/docker-ce/master/components/cli/contrib/completion/bash/docker -o /etc/bash_completion.d/docker.sh
sudo usermod -a -G docker ec2-user
```

